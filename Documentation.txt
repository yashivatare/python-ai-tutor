 DSA Tutor AI Project - Documentation

This file tracks the step-by-step progress of building the DSA Tutor AI project.

 Step 1: Project Setup & Virtual Environment

Date: 03/11/2025

 Initialized the project directory and created a dedicated Python virtual environment.

1.  Created Project Folder:
     `mkdir dsa-tutor-project`
     `cd dsa-tutor-project`

2.  Created Virtual Environment:
     `python -m venv venv`
     This creates a self-contained "prep station" (the `venv` folder) for our project's specific Python libraries, keeping our main computer clean.

3.  Activated Virtual Environment:
    `.\venv\Scripts\activate` (Windows)
     `source venv/bin/activate` (macOS/Linux)
     Our terminal prompt now shows `(venv)`, confirming we are working inside this isolated environment.

Status

Project environment is set up and active.

---

Step 2: "Hello World" API with FastAPI


 Installed the core framework for our API and ran our first "Hello World" server.

uvicorn main:app --reload
1.  Installed Libraries:
     `pip install fastapi "uvicorn[standard]"`
      FastAPI: This is the framework we use to build our API logic (the "waiter").
      Uvicorn: This is the web server that runs our API, making it accessible (the "restaurant").

2.  Created API Code:
    Created a `main.py` file.
    This file contains the code to:
        Create a FastAPI instance (`app = FastAPI()`).
        Define a "root" endpoint (`@app.get("/")`).
        Return a simple JSON message `{"message": "Hello! Welcome to the DSA Tutor API."}` when someone visits the main URL.

3.  Ran the Server:
     `uvicorn main:app --reload`
    `main:app`: Tells Uvicorn to look in the `main.py` file for the `app` object.
    `--reload`: Automatically restarts the server whenever we save changes to the file.

Status

The API server is running locally. We can access it by opening a web browser and navigating to **`http://127.0.0.1:8000`**. This confirms our server setup is working correctly.


Step 3: "Test Kitchen" - The Code Execution Endpoint

Date: 04/11/25

What We Did

We added a second "kitchen" to our API. This is the "Test Kitchen" or "Code Executor." It's a new "menu item" (endpoint) that can receive Python code, run it securely in a sandbox, and send back the result (either the output, a crash error, or a timeout error).

Key Changes in main.py:

1.  New Imports:
    from pydantic import BaseModel: To create a data "order form" (BaseModel).
    import subprocess: The Python library that lets us run terminal commands (our "sandbox").
    import sys: A utility to find the path to our current Python interpreter.

2.  Created an "Order Form" (BaseModel):
    class CodeInput(BaseModel): source_code: str
    This class forces any request to our new endpoint to be a JSON object with a string field named "source_code". This provides automatic data validation.

3.  Created a New Endpoint (POST):
    @app.post("/run_code")
    We used @app.post (instead of @app.get) because the user is sending (posting) new data (their code) to our server.

4.  Added the Executor Logic:
    The run_code function now takes code_input: CodeInput as a parameter, which FastAPI automatically validates.
    It uses a try...except block for safety.

5.  Used subprocess.run():
    This is the core of the executor. We run the command [sys.executable, '-c', code].
    timeout=5: This is our most important safety feature. It automatically kills any code (like an infinite loop) that runs for more than 5 seconds.
    check=True: This makes the function raise an error if the user's code crashes (like a ZeroDivisionError).
    capture_output=True: This "catches" the output (any print statements) and any error messages.

6.  Added Error Handling:
    We added except blocks to catch subprocess.TimeoutExpired and subprocess.CalledProcessError.
    This lets us return a specific JSON error (like "Time Limit Exceeded" or "Runtime Error") to the user.

Status

The API now has two endpoints. We tested the new /run_code endpoint using the automatic documentation page at http://127.0.0.1:8000/docs. We confirmed that it can successfully run code, catch runtime errors, and stop infinite loops.